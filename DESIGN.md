One of the core features when implementing this project was the map. We knew that the map was at the center of the client’s user experience. The thought process in creating the map includes three main ideas. First, we wanted the map to center around India. This was done using standard functions from the Folium library. Second, we wanted to create markers for every single person in our data collectors database. We then used a helper function called popup_html to create a popup profile for each individual marker when you click on it (this helper function made our app.py much cleaner). This second phase required more work, but eventually, we combined our knowledge of databases using db.execute, SQL, and Folium. It took a long time to figure out the implementation of this, as originally we had created the map’s functionality in JavaScript, and we had tried to use PHP and the Leaflet library to query the database and add markers. However, it wasn’t working. We needed to improvise, so we switched to Folium which allowed us to create the map using Python (in the app.py file), thus making it easier for us to query the database. We then created a loop to retrieve the needed information from the newly created list of dictionaries, and input them into the Folium marker functions. The third main idea of the map was to filter out information. This required us to do database queries based on user inputs, which was easy to implement but required us to make failsafes for edge cases and malicious inputs. 

We also needed to account for the layout and design of the website. This required formatting. One of the key formatting issues was in displaying the map on an html page. In Folium, every time the map is updated (such as a new filter in place) it overwrites the html that the map is in. This meant we couldn’t add important features like a navbar. To solve this, we decided to store the Folium map in mapdata.html, and extend it in map.html at the bottom of the page. This, however, meant we couldn’t extend the layout onto map.html, so we had to copy and paste it into the head. Another design decision involved the register and dashboard pages. Those pages use tables and rows to format the information on the website into two columns. However, we discovered that this approach wasn’t mobile-friendly. The right side columns would be placed outside of the page. This meant we had to change the CSS so that whenever the page got to a certain size, it would automatically reformat the table to fit into one column.
  
The central component of the backend is a database called groundup.db. This SQL database has three tables. The first table, called users, remembers the username and password of a user from when they registered. It also records if the user is a data collector or client, based on which registration form was used, and records this value in the type column of the table. This allows the user to be redirected to the client or the collector dashboard when they login. The second table, called data collectors, stores the information of all the data collectors that are currently registered. This table holds the key facts about the data collector registered, including id, name, latitude and longitude, occupation, degree, and sector. Additionally, the table has a foreign key userid which references the id in the users table. This allows us to associate each data collector with a login, so the user-specific information above can be presented when logging into the platform as a collector. Finally, there is a very similar table called datacollectorsfiltered. This holds the same information as datacollectors (minus the userid foreign key), but is used to generate the map page. When the user filters data collectors by certain parameters, the resulting data collectors are duplicated from the datacollectors database into the datacollectorsfiltered database. The map endpoint, when called, then draws the data collectors from the datacollectorsfiltered database, allowing us to only show certain data collectors based on the user parameters.
 
The heart of app.py is the index function. The function has two parts, one for when the currently logged in user is a client, and one for when that user is a data collector. The type of user currently logged in is stored with flask session cookies.
If the current user is a client (data seeker), then app.py renders the client homepage (client.html) and populate the dropdown menus in client.html with all of the unique occupations, educations, and sectors of the data collectors currently in the database. This allows the client to filter for data collectors based on location, occupation, education, and sector using dropdowns and text/number input boxes in the client homepage. 
When the client submits the filter form, the data is sent through post, and read in the index function. The function then needs to match to data collectors that fit into the filtering categories inputted. However, if the client only filtered certain categories, only these categories should be included in the search. Finally, if the client does not apply any filters and just clicks “filter” while leavin all the filters blank, then all of the data collector should be rendered. To accomplish this complex request, we dynamically generate SQL search query based on which values are empty or full (to search)

If the current user is a data collector, then app.py renders the collector.html page, which shows the current data collector logged in, including their username, and characteristics (location, sector, education, etc.). Collector.html also has a series of form inputs which can be used to edit the specific characteristics of the data collector in the database. When this form is submitted via POST, app,py updates the database, and re-renders template with the new values
App.py handles logging in, registering, and changing the password with three different methods. The register function detects whether the user registers with the data collector registration form or the client registration form and updates the database with the username, password hash, and user type accordingly. Login then detects which type of user the login credentials correspond to, and if the user is a new data collector, it creates a blank datacollector that has a foreign key linked to the login. The user can then update the name, location, etc. of the data collector in the data collector profile. 

Forgot password allows users to reset their password if they know their username. The html elements are all in login.html, however, the forgot password button opens up into a new popup form. The inputs of this form (username and password) ‘POST’ to a different endpoint (/forgot). This is a separate function in app.py, which retrieves the user input. If the inputted username matches an existing username, a SQL query overwrites the existing password with the newly inputted password using UPDATE. Once that’s done, the user can log in as they normally would with the new password. 
